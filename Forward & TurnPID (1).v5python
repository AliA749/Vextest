{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nleft_motor_back = Motor(Ports.PORT11, GearSetting.RATIO_18_1, False)\nleft_motor_middle = Motor(Ports.PORT12, GearSetting.RATIO_18_1, False)\nleft_motor_front = Motor(Ports.PORT14, GearSetting.RATIO_18_1, False)\nright_motor_back = Motor(Ports.PORT20, GearSetting.RATIO_18_1, True)\nright_motor_middle = Motor(Ports.PORT19, GearSetting.RATIO_18_1, True)\nright_motor_front = Motor(Ports.PORT18, GearSetting.RATIO_18_1, True)\ncontroller_1 = Controller(PRIMARY)\ninertial_9 = Inertial(Ports.PORT9)\nbumper_a = Bumper(brain.three_wire_port.a)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:      1/8/2024\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\n#Note: Correctly Select the motors (Manual and Auto motor name giver is different, Manual has Motor group auto doesnt)\n#Note: Fix kd and kp for Auto turning\n\n# Library imports\nfrom vex import *\n    \ndef driver_control():\n    brain.screen.print(\"Going Manual\")\n    controller_1.screen.print(\"Going Manual\")\n    dead_band = 14\n    # Begin project code\n    #Arm Up-Down code\n    def Amovement():\n        if controller_1.buttonA.pressing():\n            #FrontLeft.set_velocity(50,PERCENT)\n            #FrontLeft.spin(FORWARD)\n            wait(3,MSEC)\n        elif controller_1.buttonB.pressing():\n            #FrontRight.set_velocity(20,PERCENT)\n            #FrontRight.spin(FORWARD)\n            wait(3,MSEC)\n    controller_1.buttonA.pressed(Amovement)\n    wait(5,MSEC)\n\n    while True:\n        axis_3_pos = controller_1.axis3.position()\n        axis_2_pos = controller_1.axis2.position()\n        #Drive\n        if abs(axis_3_pos) + abs(axis_2_pos) > dead_band:\n            #right_motors.spin(FORWARD)\n            #left_motors.spin(FORWARD)\n            #FrontLeft.spin(FORWARD)\n            #FrontRight.spin(FORWARD)\n            #left_motors_motor_a.set_velocity((axis_3_pos),PERCENT)\n            #left_motors_motor_b.set_velocity((axis_3_pos),PERCENT)\n            #FrontLeft.set_velocity((axis_3_pos),PERCENT)\n            controller_1.screen.print(axis_3_pos)\n            wait(5,MSEC)\n\n            #right_motors_motor_a.set_velocity((axis_2_pos), PERCENT)\n            #right_motors_motor_b.set_velocity((axis_2_pos), PERCENT)\n            #FrontRight.set_velocity((axis_2_pos), PERCENT)\n            controller_1.screen.print(axis_2_pos)\n            wait(5,MSEC)\n        \n\n        else:\n            #left_motors.set_velocity(0, PERCENT)\n            #FrontLeft.set_velocity(0, PERCENT)\n            #right_motors.set_velocity(0, PERCENT)\n            #FrontRight.set_velocity(0, PERCENT)\n\n            #left_motors_motor_a.spin(FORWARD)\n            #left_motors_motor_b.spin(FORWARD)\n            #FrontLeft.spin(FORWARD)\n\n\n            #right_motors_motor_a.spin(FORWARD)\n            #right_motors_motor_b.spin(FORWARD)\n            #FrontLeft.spin(FORWARD)\n\n            wait(5, MSEC)\n\ndef autonomous():\n    brain.screen.print(\"Going Auto\");\n    controller_1.screen.print(\"Going Auto\")\n#Make sure to change the ports\n#READ: Set kd and kp to small values or even 0, then start testing\n\n#Values will be calibrated\nglobal kd\nglobal kp\n#THIS KD & KP IS FOR GOING STRAIT (Lines 79-80 for turning kp & kd)\nkd = 0.5\nkp = 0.5\n\n#Set the Wheel data\nwheel_circumference = 260;\ndegrees_per_rotation = 360;\nglobal distance_per_degree\n\n#distance that it traveled for each degree the wheel rotated\ndistance_per_degree = wheel_circumference / degrees_per_rotation;\n\nmovement = \"Turn\"\n\ndef path():\n    #Forward kd % kp\n    f_kp = 0.5\n    f_kd = 0.5\n\n    #Turn Kd & Kp\n    #Find Balue Vellow\n    t_kp = 0.5\n    t_kd = 0.78\n\n    #Right Positive Turn, Left Negative Turn\n\n    #Forward\n    movement = \"Forward\"\n    distancee = 0 * 1.04472368421;\n    forward_pid(distancee, f_kp, f_kd);\n\n    #Right\n    movement = \"Turn\";\n    distancee = 90;\n    forward_pid(distancee, t_kp, t_kd);\n\n    #Forward\n    movement = \"Forward\"\n    distancee = 0 * 1.04472368421;\n    forward_pid(distancee, f_kp, f_kd);\n\n    #Left\n    movement = \"Turn\";\n    distancee = -90;\n    forward_pid(distancee, t_kp, t_kd);\n\n    #Forward\n    movement = \"Forward\"\n    distancee = 0 * 1.04472368421;\n    forward_pid(distancee, f_kp, f_kd);\n\n    #Left\n    movement = \"Turn\";\n    distancee = -90;\n    forward_pid(distancee, t_kp, t_kd);\n\n    #Forward - Goes in net - n (n: Sequence of going into the net)\n    movement = \"Forward\"\n    distancee = 0 * 1.04472368421;\n    forward_pid(distancee, f_kp, f_kd);\n\n    #Back - n\n    movement = \"Forward\"\n    distancee = -0 * 1.04472368421;\n    forward_pid(distancee, f_kp, f_kd);\n\n    #180 Turn (Right) - n\n    movement = \"Turn\";\n    distancee = 180;\n    forward_pid(distancee, t_kp, t_kd);\n\n    #Forward\n    movement = \"Forward\"\n    distancee = 0 * 1.04472368421;\n    forward_pid(distancee, f_kp, f_kd);\n\n    #180 Turn (Right)\n    movement = \"Turn\";\n    distancee = 180;\n    forward_pid(distancee, t_kp, t_kd);\n\n    #Forward - Goes in net - n\n    movement = \"Forward\"\n    distancee = 0 * 1.04472368421;\n    forward_pid(distancee, f_kp, f_kd);\n\n    #Back - n\n    movement = \"Forward\"\n    distancee = -0 * 1.04472368421;\n    forward_pid(distancee, f_kp, f_kd);\n\n    #180 Turn (Right) - n\n    movement = \"Turn\";\n    distancee = 180;\n    forward_pid(distancee, t_kp, t_kd);\n\n    #Forward\n    movement = \"Forward\"\n    distancee = 0 * 1.04472368421;\n    forward_pid(distancee, f_kp, f_kd);\n\n    #Left\n    movement = \"Turn\";\n    distancee = -90;\n    forward_pid(distancee, t_kp, t_kd);\n\n    #Forward\n    movement = \"Forward\"\n    distancee = 0 * 1.04472368421;\n    forward_pid(distancee, f_kp, f_kd);\n\n    #Right\n    movement = \"Turn\";\n    distancee = 90;\n    forward_pid(distancee, t_kp, t_kd);\n\n    #Right\n    movement = \"Turn\";\n    distancee = 90;\n    forward_pid(distancee, t_kp, t_kd);\n\n    #Forward\n    movement = \"Forward\"\n    distancee = 0 * 1.04472368421;\n    forward_pid(distancee, f_kp, f_kd);\n\n    #Right\n    movement = \"Turn\";\n    distancee = 90;\n    forward_pid(distancee, t_kp, t_kd);\n\n    #Forward - Goes in net - n\n    movement = \"Forward\"\n    distancee = 0 * 1.04472368421;\n    forward_pid(distancee, f_kp, f_kd);\n\n    #Back - n\n    movement = \"Forward\"\n    distancee = -0 * 1.04472368421;\n    forward_pid(distancee, f_kp, f_kd);\n\n    #180 Turn (Right) - n\n    movement = \"Turn\";\n    distancee = 180;\n    forward_pid(distancee, t_kp, t_kd);\n\n#In MM\nglobal distancee\n\nif movement == \"Forward\":\n    distancee = 1000 * 1.04472368421;\nelse:\n    distancee = 90\n    print(\"TURN\")\n    #THIS KP & KD VALUE FOR TURNING TO THE SIDE\n    #Find Kp first then find kd\n    #ADdd more comments\n    #Its a PD not PID\n    #FInd balue vellow\n    kd = 0.5\n    kp = 0.78\n# Begin project code\n\n\n#Might Change\nleft_motor_back.set_velocity(1, PERCENT)\nleft_motor_middle.set_velocity(1, PERCENT)\nleft_motor_front.set_velocity(1, PERCENT)\n\nright_motor_back.set_velocity(1, PERCENT)\nright_motor_middle.set_velocity(1, PERCENT)\nright_motor_front.set_velocity(1, PERCENT)\n\ndef forward_pid(distancee, kp, kd):\n    SetDegrees()\n    #This fuction moves the robot;\n    #motor speed = error * kp * (â–³error/time) * kd;\n    SetDegrees();\n    brain.timer.clear();\n    wait(5,MSEC)\n    error = distancee;\n    old_error = error;\n    time_passed = 0.005\n\n    left_motor_back.spin(FORWARD)\n    left_motor_middle.spin(FORWARD)\n    left_motor_front.spin(FORWARD)\n    right_motor_back.spin(FORWARD)\n    right_motor_middle.spin(FORWARD)\n    right_motor_front.spin(FORWARD)\n\n    #Remember to change the true until the bot has stopped\n    while True:\n        bumper_a.pressed(robot_stop)\n\n        distance_traveled = float(distance_traveled_calc())\n        error = float(error)\n        error = float(distancee) - distance_traveled;\n        error_change = error - old_error;\n        if error_change < 0:\n            error_change = error_change * -1\n        old_error = error;\n\n        #Get the time\n        time_passed = float(brain.timer.time(SECONDS));\n        controller_1.screen.print(\"Time:\" + str(time_passed))\n        \n\n        #PID calculation (Nightmare)\n        error_changed = error_change / time_passed;\n        controller_1.screen.print(\"Error: \" + str(error_changed))\n        motor_speed = (error * kp) + (error_changed * kd);\n        controller_1.screen.print(motor_speed)\n\n\n        #Cap the max and min speed %\n        if motor_speed > 100:\n            motor_speed = 100;\n\n        oposite = motor_speed * -1\n        \n        #High Temp Check\n        if left_motor_back.temperature(PERCENT) >= 90 or left_motor_front.temperature(PERCENT) >= 90 or left_motor_middle.temperature(PERCENT) >= 90:\n            controller_1.screen.print(\"Left Wheels Overheating, it is highly recommended to let it cool!\")\n            brain.screen.print(\"Left Wheels Overheating, it is highly recommended to let it cool!\")\n        elif right_motor_back.temperature(PERCENT) >= 90 or right_motor_front.temperature(PERCENT) >= 90 or right_motor_middle.temperature(PERCENT) >= 90:\n            controller_1.screen.print(\"Right Wheels Overheating, it is highly recommended to let it cool!\")\n            brain.screen.print(\"Right Wheels Overheating, it is highly recommended to let it cool!\")\n\n        #Set the speed\n        if movement == \"Forward\":\n            #Going Forward\n            left_motor_back.set_velocity(motor_speed, PERCENT)\n            left_motor_middle.set_velocity(motor_speed, PERCENT)\n            left_motor_front.set_velocity(motor_speed, PERCENT)\n\n            right_motor_back.set_velocity(motor_speed, PERCENT)\n            right_motor_middle.set_velocity(motor_speed, PERCENT)\n            right_motor_front.set_velocity(motor_speed, PERCENT)\n        else:\n            #Right Turning \n            left_motor_back.set_velocity(motor_speed, PERCENT)\n            left_motor_middle.set_velocity(motor_speed, PERCENT)\n            left_motor_front.set_velocity(motor_speed, PERCENT)\n\n            right_motor_back.set_velocity(oposite, PERCENT)\n            right_motor_middle.set_velocity(oposite, PERCENT)\n            right_motor_front.set_velocity(oposite, PERCENT)\n\n        #Loop Ender - might need to fix\n        if distance_traveled == distancee:\n            break;\n\n        brain.screen.print(inertial_9.rotation(DEGREES))\n        print(inertial_9.rotation(DEGREES))\n        wait(5,MSEC)\n\n\n\ndef distance_traveled_calc():\n    left_front = float(left_motor_front.position(DEGREES));\n    left_middle = float(left_motor_middle.position(DEGREES));\n    left_back = float(left_motor_back.position(DEGREES));\n\n    right_front = float(right_motor_front.position(DEGREES));\n    right_middle = float(right_motor_middle.position(DEGREES));\n    right_back = float(right_motor_back.position(DEGREES));\n\n    right_movement = right_front + right_middle + right_back;\n    right_movement = right_movement * -1;\n\n    average = left_front + left_middle + left_back + right_movement;\n    average = average / 6;\n    return (average * distance_per_degree)\n\n#MAY CHANGE\ndef  TurnPID():\n    brain.timer.clear();\n    wait(5,MSEC);\n    error = 90;\n    old_error = error;\n    time_passed = 0.005\n\n\ndef SetDegrees():\n    left_motor_back.set_position(0, DEGREES);   \n    left_motor_middle.set_position(0, DEGREES);\n    left_motor_front.set_position(0, DEGREES);\n\n    right_motor_back.set_position(0, DEGREES);\n    right_motor_middle.set_position(0, DEGREES);\n    right_motor_front.set_position(0, DEGREES);\n\n#Stop\ndef robot_stop():\n    while True:\n        left_motor_back.stop();\n        left_motor_middle.stop();\n        left_motor_front.stop();\n\n        right_motor_back.stop();\n        right_motor_middle.stop();\n        right_motor_front.stop();\n\n        motor_speed = 0;\n        kd = 0;\n        kp = 0;\n\nforward_pid(distancee, kp, kd)\n\n#forward_pid(distancee, kp, kd)","textLanguage":"python","rconfig":[{"port":[11],"name":"left_motor_back","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[12],"name":"left_motor_middle","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[14],"name":"left_motor_front","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[20],"name":"right_motor_back","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[19],"name":"right_motor_middle","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[18],"name":"right_motor_front","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[9],"name":"inertial_9","customName":false,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1],"name":"bumper_a","customName":false,"deviceType":"Bumper","deviceClass":"bumper","setting":{"id":"partner"},"triportSourcePort":22}],"slot":6,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.5","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}